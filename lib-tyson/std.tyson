; atoms
(def {nil} {})
(def {true} 1)

(def {fun} (\ {args body} {
  ; Better function definitions
  def (head args) (\ (tail args) body)
}))

; Stuff for currying
(fun {unpack f xs} {
  eval (join (list f) xs)
})

(fun {pack f & xs} {
  f xs
})

; curried and uncurried calling
(def {curry} unpack)
(def {uncurry} pack)

(fun {do & l} {
  ; perform stuff in sequence
  ; returns the result of the last thing it does

  if (== l nil)
  {nil}
  {last l}
})

; open new scope.
; save results to local variables using the = operator
(fun {let b} {
  ((\ {_} b) ())
})

; logical funcitons
(fun {not x} {- 1 x})
(fun {or x y} {+ x y})
(fun {and x y} {* x y})

(fun {reverse l} {
  if (== l {})
    {{}}
    {join (reverse (tail l)) (head l)}
})

; list functions
(fun {fst l} {
  eval (head l)
})

(fun {snd l} {
  eval (head (tail l))
})

(fun {nth n l} {
  ; returs nth item in the list
  if (== n 0)
    {fst l}
    {nth (- n 1) (tail l)}
})

(fun {last l} {
  ; returns the last item in the list
  nth (- (len l) 1) l
})

(fun {take n l} {
  ; returns first n items in a list
  if (== n 0)
  {nil}
  {join (head l) (take (- n 1) (tail l))}
})

(fun {drop n l} {
  ; returns all except the n first elements in a list
  if (== n 0)
  {l}
  {drop (- n 1) (tail l)}
})

(fun {split n l} {
  ; Split list at index n
  list (take n l) (drop n l)
})

(fun {in x l} {
  ; returns true if x is an element in l
  if (== l nil)
  {false}
  {if (== x (fst l))
    {true}
    {in x (tail l)}
  }
})

(fun {map f l} {
  if (== l nil)
  {nil}
  {join (list (f (fst l))) (map f (tail l))}
})

(fun {filter f l} {
  if (== l nil)
  {nil}
  {join (
    if (f (fst l))
    {head l}
    {nil})
  (filter f (tail l))
  }
})

(fun {foldLeft f z l} {
  if (== l nil)
  {z}
  {foldLeft f (f z (fst l)) (tail l)}
})

(fun {sum l} {
  foldLeft + 0 l
})

(fun {cumProd l} {
  foldLeft * 1 l
})

; conditional functions
(fun {select & cs} {
  ; Like a switch case but cooler
  ; takes in 0 or more 2 tuples as input
  ; Evaluate the first element. If true, evaluate and return second.
  ; else perform same thing on rest of list.
  if (== cs nil)
  {error "No selection found"}
  {if (fst (fst cs))
    {snd (fst cs)}
    {unpack select (tail cs)}
  }
})

; default case for switch statement
(fun {otherwise} true)

(fun {case x & cs} {
  ; regular case match with equality check
  ; takes in 0 or more 2 tuples as input
  ; Evaluate the first element. If true, evaluate and return second.
  ; else perform same thing on rest of list.

  if (== cs nil)
  {error "No case found"}
  {if (== x (fst (fst cs)))
    {snd (fst cs)}
    {unpack case (join (list x) (tail cs))}
  }
})

(print "loaded standard library")
